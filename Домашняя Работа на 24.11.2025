#include <iostream>
#include <new>

struct IntArray {
    int* data;
    size_t sz;

    explicit IntArray(size_t capacity = 0) : data(nullptr), sz(0) {
        if (capacity > 0) {
            data = new int[capacity];
            sz = capacity;
        }
    }

    IntArray(const IntArray& other) : data(nullptr), sz(other.sz) {
        if (sz > 0) {
            data = new int[sz];
            for (size_t i = 0; i < sz; ++i) {
                data[i] = other.data[i];
            }
        }
    }

    ~IntArray() {
        delete[] data;
    }

    void add(int value) {
        int* tmp = new int[sz + 1];
        for (size_t i = 0; i < sz; ++i) {
            tmp[i] = data[i];
        }
        tmp[sz] = value;
        delete[] data;
        data = tmp;
        ++sz;
    }

    size_t size() const noexcept {
        return sz;
    }

    int get(size_t i) const noexcept {
        return data[i];
    }

    int& operator[](size_t i) {
        return data[i];
    }

    const int& operator[](size_t i) const {
        return data[i];
    }
};

struct IntMatrix {
    IntArray rows; // хранит ВСЕ элементы подряд
    size_t nrows, ncols;

    IntMatrix(size_t r, size_t c) : nrows(r), ncols(c) {
        if (r > 0 && c > 0) {
            rows = IntArray(r * c);
        }
    }

    int& at(size_t i, size_t j) {
        return rows[i * ncols + j];
    }

    const int& at(size_t i, size_t j) const {
        return rows[i * ncols + j];
    }

    void print() const {
        for (size_t i = 0; i < nrows; ++i) {
            for (size_t j = 0; j < ncols; ++j) {
                std::cout << at(i, j);
                if (j + 1 < ncols) std::cout << ' ';
            }
            std::cout << '\n';
        }
    }

    // Команда I: добавить строку после указанной (или в начало, если idx == 0)
    bool insertRow(size_t idx, int value) {
        if (idx > nrows) return false; // invalid index

        size_t newRow = (idx == 0) ? 0 : idx;
        size_t newNRows = nrows + 1;
        IntArray newRows(newNRows * ncols);

        size_t src = 0;
        size_t dst = 0;

        for (size_t i = 0; i < newRow; ++i) {
            for (size_t j = 0; j < ncols; ++j) {
                newRows[dst++] = rows[src++];
            }
        }

        for (size_t j = 0; j < ncols; ++j) {
            newRows[dst++] = value;
        }

        for (size_t i = newRow; i < nrows; ++i) {
            for (size_t j = 0; j < ncols; ++j) {
                newRows[dst++] = rows[src++];
            }
        }

        rows = newRows;
        nrows = newNRows;
        return true;
    }

    // Команда II: добавить столбец после указанного (или перед первым, если idx == 0)
    bool insertCol(size_t idx, int value) {
        if (idx > ncols) return false;

        size_t newCol = (idx == 0) ? 0 : idx;
        size_t newNCols = ncols + 1;
        IntArray newRows(nrows * newNCols);

        size_t dst = 0;
        for (size_t i = 0; i < nrows; ++i) {
            for (size_t j = 0; j < newCol; ++j) {
                newRows[dst++] = at(i, j);
            }
            newRows[dst++] = value;
            // После вставки
            for (size_t j = newCol; j < ncols; ++j) {
                newRows[dst++] = at(i, j);
            }
        }

        rows = newRows;
        ncols = newNCols;
        return true;
    }
};

int main() {
    if (std::cin.fail()) {
        return 1;
    }

    size_t rows, cols;
    if (!(std::cin >> rows >> cols)) {
        return 1;
    }

    IntMatrix matrix(rows, cols);
    for (size_t i = 0; i < rows; ++i) {
        for (size_t j = 0; j < cols; ++j) {
            if (!(std::cin >> matrix.at(i, j))) {
                return 1;
            }
        }
    }

    int cmd, p1, p2;
    while (std::cin >> cmd >> p1 >> p2) {
        bool ok = false;
        try {
            if (cmd == 1) {
                size_t idx = (p1 == 0) ? 0 : static_cast<size_t>(p1);
                ok = matrix.insertRow(idx, p2);
            } else if (cmd == 2) {
                // Команда II: добавить столбец
                size_t idx = (p1 == 0) ? 0 : static_cast<size_t>(p1);
                ok = matrix.insertCol(idx, p2);
            } else {
                std::cerr << "Unknown command: " << cmd << '\n';
                return 3;
            }
        } catch (const std::bad_alloc&) {
            return 2;
        }

        if (!ok) {
            return 3;
        }

        matrix.print();
    }

    if (!std::cin.eof()) {
        return 1;
    }

    return 0;
}
